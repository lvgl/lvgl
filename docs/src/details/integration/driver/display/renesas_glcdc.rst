.. _renesas_glcdc:

=============
Renesas GLCDC
=============

Overview
--------

.. image:: /_static/images/renesas/glcdc.png
    :alt: Architectural overview of Renesas GLCDC
    :align: center

<br/>

GLCDC is a multi-stage graphics output peripheral used in Renesas MCUs.
It is designed to automatically generate timing and data signals for different LCD panels.

- Supports LCD panels with RGB interface (up to 24 bits) and sync signals (HSYNC, VSYNC and Data Enable optional)
- Supports various color formats for input graphics planes (RGB888, ARGB8888, RGB565, ARGB1555, ARGB4444, CLUT8, CLUT4, CLUT1)
- Supports the Color Look-Up Table (CLUT) usage for input graphics planes (ARGB8888) with 512 words (32 bits/word)
- Supports various color formats for output (RGB888, RGB666, RGB565, Serial RGB888)
- Can input two graphics planes on top of the background plane and blend them on the screen
- Generates a dot clock to the panel. The clock source is selectable from internal or external (LCD_EXTCLK)
- Supports brightness adjustment, contrast adjustment, and gamma correction
- Supports GLCDC interrupts to handle frame-buffer switching or underflow detection


Setting up a project and further integration with Renesas' ecosystem is described in detail on :ref:`page Renesas <renesas>`.
Check out the following repositories for ready-to-use examples:

- `EK-RA8D1 <https://github.com/lvgl/lv_port_renesas_ek-ra8d1>`__
- `EK-RA6M3G <https://github.com/lvgl/lv_port_renesas_ek-ra6m3g>`__
- `RX72N Envision Kit <https://github.com/lvgl/lv_port_renesas_rx72n-envision-kit>`__


Prerequisites
-------------

- This diver relies on code generated by eÂ² studio. Missing the step while setting up the project will cause a compilation error.
- Activate the diver by setting :c:macro:`LV_USE_RENESAS_GLCDC` to ``1`` in your *"lv_conf.h"*.

Usage
-----

There is no need to implement any platform-specific functions.

The following code demonstrates using the diver in :cpp:enumerator:`LV_DISPLAY_RENDER_MODE_DIRECT` mode.

.. code-block:: c

    lv_display_t * disp = lv_renesas_glcdc_direct_create();
    lv_display_set_default(disp);

To use the driver in :cpp:enumerator:`LV_DISPLAY_RENDER_MODE_PARTIAL` mode, an extra buffer must be allocated,
preferably in the fastest available memory region.

Buffer swapping can be activated by passing a second buffer of same size instead of the :cpp:expr:`NULL` argument.

.. code-block:: c

    static lv_color_t partial_draw_buf[DISPLAY_HSIZE_INPUT0 * DISPLAY_VSIZE_INPUT0 / 10] BSP_PLACE_IN_SECTION(".sdram") BSP_ALIGN_VARIABLE(1024);

    lv_display_t * disp = lv_renesas_glcdc_partial_create(partial_draw_buf, NULL, sizeof(partial_draw_buf));
    lv_display_set_default(disp);

.. note::

    Partial mode can be activated via the macro in ``src/board_init.c`` file of the demo projects.


Screen rotation
"""""""""""""""

Software based screen rotation is supported in partial mode. It uses the common API, no extra configuration is required:

.. code-block:: c

    lv_display_set_rotation(lv_display_get_default(), LV_DISP_ROTATION_90);
    /* OR */
    lv_display_set_rotation(lv_display_get_default(), LV_DISP_ROTATION_180);
    /* OR */
    lv_display_set_rotation(lv_display_get_default(), LV_DISP_ROTATION_270);

Make sure the heap is large enough, as a buffer with the same size as the partial buffer will be allocated.
